package com.los.service.impl;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import com.los.exception.ValidationException;
import com.los.kafka.Consumer;
import com.los.kafka.KafkaResponse;
import com.los.kafka.Producer;
import com.los.model.OtpModel;
import com.los.model.common.OtpRequestModel;
import com.los.model.common.OtpResponse;
import com.los.model.common.ProcessName;
import com.los.model.common.ValidationResponce;
import com.los.notification.ITemplateRepository;
import com.los.repository.IOtpRepository;
import com.los.service.IOtpService;
import com.los.util.Util;

import lombok.extern.slf4j.Slf4j;

/**
 * This is service layer to hold all business logic
 */
@Service
@Slf4j
public class OtpServiceImpl implements IOtpService {
	/*
	 * Initialize the repository for database connection
	 */
	@Autowired
	IOtpRepository otpRepository;
	@Autowired
	ITemplateRepository iTemplateRepository;

	@Autowired
	Producer producer;

	@Autowired
	Consumer consumer;

	/*
	 * Initialize the Util class for generate otp
	 */
	@Autowired
	Util util;

	/*
	 * This constructor generated for junit test case
	 */
	public OtpServiceImpl(IOtpRepository otpRepository, Util util) {
		super();
		this.otpRepository = otpRepository;
		this.util = util;
	}

	/**
	 * This method to create otp
	 */
	@Override
	public OtpResponse createOtp(OtpRequestModel otpRequestModel) {
		/*
		 * This is checking for operation type
		 */
		if (!otpRequestModel.getOperationType().equalsIgnoreCase("Generate")) {
			throw new ValidationException("Operation Type is not correctly submitted");
		}
		/*
		 * This is date time formater for convert date of string to date time
		 */
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		LocalDateTime dateTime = null;
		try {
			dateTime = LocalDateTime.parse(otpRequestModel.getStartTime(), formatter);
		} catch (Exception e) {
			throw new ValidationException("please enter the valid Date and Time Format");
		}

		String processName = ProcessName.valueOf(otpRequestModel.getProcessName().toUpperCase()).name();
		List<OtpModel> otpModelExisted2 = otpRepository.getOtpModel(LocalDateTime.now().minusMinutes(10),
				otpRequestModel.getMobile(), "GENERATED", processName);
		log.info("otp model list " + otpModelExisted2);
		if (otpModelExisted2.size() >= 3 && otpModelExisted2.get(otpModelExisted2.size() - 1).getCreatedOn()
				.plusMinutes(10).isAfter(LocalDateTime.now())) {

			throw new ValidationException("limit exceeded. Please try after 10 minutes");
		}

		Timestamp timeStamp = Timestamp.valueOf(dateTime);
		log.info("timestamp is :" + timeStamp);
		byte[] channel = otpRequestModel.getChannel().getBytes();
		String channelKey = "";
		for (int i = 0; i < channel.length; i++) {
			channelKey = channelKey.concat("" + channel[i]);
		}
		log.info("channelKey " + channelKey);

		byte[] proceName = otpRequestModel.getProcessName().getBytes();
		String proceNameKey = "";
		for (int i = 0; i < proceName.length; i++) {
			proceNameKey = proceNameKey.concat("" + proceName[i]);
		}

		/*
		 * This is secret key for otp generation
		 */
		String secret = "" + timeStamp.toInstant().toEpochMilli() + otpRequestModel.getMobile() + channelKey
				+ proceNameKey;

		/*
		 * This OTP is generated by Util class with help of HmacSHA256
		 */
		String otp = Util.generateTOTP256(secret, Integer.parseInt(otpRequestModel.getDuration()),
				otpRequestModel.getDigit());
		log.info("otp is :" + otp);
		/*
		 * This is otpId and created with UUID
		 */
		String otpId = UUID.randomUUID().toString().substring(0, 8);
		OtpModel newModel = OtpModel.builder().countryCode(Long.parseLong(otpRequestModel.getCountryCode()))
				.mobileNumber(otpRequestModel.getMobile()).createdBy("System").createdOn(LocalDateTime.now())
				.otpId(otpId).processName(ProcessName.valueOf(otpRequestModel.getProcessName().toUpperCase()).name())
				.status("GENERATED").build();
		otpRepository.save(newModel);
		KafkaResponse kafkaResponse = KafkaResponse.builder().countryCode(otpRequestModel.getCountryCode())
				.generatedTime(newModel.getCreatedOn().toString()).mobile(otpRequestModel.getMobile()).otp(otp)
				.otpId(otpId).processName(newModel.getProcessName()).build();
		producer.publishToTopic(kafkaResponse);

		CompletableFuture.delayedExecutor(1, TimeUnit.SECONDS).execute(() -> {
			String mobile = "+" + newModel.getCountryCode() + newModel.getMobileNumber();
			KafkaResponse kafkaResponse2 = consumer.sendingOTPToMobile(mobile);
			log.info("Kafka consumed message is " + kafkaResponse2);
		});
		return new OtpResponse(HttpStatus.OK.value(), "Otp is successfully generated", otp,
				otpRequestModel.getDuration(), otpId);
	}

	/**
	 * This method to validate otp
	 */
	@Override
	public ValidationResponce validatedOtp(OtpRequestModel otpValidationModel) {
		/*
		 * This is checking for operation type
		 */
		if (!otpValidationModel.getOperationType().equalsIgnoreCase("Validate")) {
			throw new ValidationException("Operation Type is not correctly submitted");
		}

		ProcessName.valueOf(otpValidationModel.getProcessName().toUpperCase()).name();

		/*
		 * This is date time formater for convert date of string to date time
		 */
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
		LocalDateTime dateTime = null;
		try {
			dateTime = LocalDateTime.parse(otpValidationModel.getStartTime(), formatter);
		} catch (Exception e) {
			throw new ValidationException("please enter the valid Date and Time Format");
		}

		Timestamp timeStamp = Timestamp.valueOf(dateTime);
		log.info("timestamp is :" + timeStamp);
		byte[] channel = otpValidationModel.getChannel().getBytes();
		String channelKey = "";
		for (int i = 0; i < channel.length; i++) {
			channelKey = channelKey.concat("" + channel[i]);
		}
		log.info("channelKey " + channelKey);

		byte[] proceName = otpValidationModel.getProcessName().getBytes();
		String proceNameKey = "";
		for (int i = 0; i < proceName.length; i++) {
			proceNameKey = proceNameKey.concat("" + proceName[i]);
		}
		String secret = "" + timeStamp.toInstant().toEpochMilli() + otpValidationModel.getMobile() + channelKey
				+ proceNameKey;

		/*
		 * This OTP is regenerated by Util class with help of HmacSHA256 for otp
		 * validation
		 */
		String otp = Util.generateTOTP256(secret, Integer.parseInt(otpValidationModel.getDuration()),
				otpValidationModel.getDigit());
		List<OtpModel> generateddList = otpRepository.findByOtpIdAndStatus(otpValidationModel.getOtpId(), "GENERATED");
		if (generateddList.isEmpty()) {
			throw new ValidationException("Otp is not generated.");
		}
		OtpModel otpModelData = generateddList.get(0);
		if (otpModelData.getCreatedOn().plusSeconds(180).isAfter(LocalDateTime.now())
				&& otp.equals(otpValidationModel.getGeneratedOtp())) {
			List<OtpModel> validList = otpRepository.findByOtpIdAndStatus(otpValidationModel.getOtpId(), "VERIFIED");
			if (!validList.isEmpty()) {
				throw new ValidationException("OTP is already verified");
			}

			OtpModel newModel = OtpModel.builder().countryCode(Long.parseLong(otpValidationModel.getCountryCode()))
					.mobileNumber(otpValidationModel.getMobile()).createdBy("System")
					.createdOn(otpModelData.getCreatedOn()).otpId(otpValidationModel.getOtpId())
					.processName(otpValidationModel.getProcessName().toUpperCase()).status("VERIFIED").build();
			otpRepository.save(newModel);
			return ValidationResponce.builder().status(HttpStatus.OK.value()).message("OTP validated successfully")
					.build();
		} else if (dateTime.plusSeconds(180).isBefore(LocalDateTime.now())
				&& otp.equals(otpValidationModel.getGeneratedOtp())) {
			OtpModel newModel = OtpModel.builder().countryCode(Long.parseLong(otpValidationModel.getCountryCode()))
					.mobileNumber(otpValidationModel.getMobile()).createdBy("System")
					.createdOn(otpModelData.getCreatedOn()).otpId(otpValidationModel.getOtpId())
					.processName(otpValidationModel.getProcessName().toUpperCase()).status("FAILED").build();
			otpRepository.save(newModel);
			return ValidationResponce.builder().status(HttpStatus.UNPROCESSABLE_ENTITY.value())
					.message("Otp is expired").build();
		} else {
			List<OtpModel> validList1 = otpRepository.findByOtpIdAndStatus(otpValidationModel.getOtpId(), "FAILED");
			if (validList1.size() >= 3) {
				throw new ValidationException("too many attaemps. Please regeneate the otp for further validation.");
			}
			OtpModel newModel = OtpModel.builder().countryCode(Long.parseLong(otpValidationModel.getCountryCode()))
					.mobileNumber(otpValidationModel.getMobile()).createdBy("System")
					.createdOn(otpModelData.getCreatedOn()).otpId(otpValidationModel.getOtpId())
					.processName(otpValidationModel.getProcessName().toUpperCase()).status("FAILED").build();
			otpRepository.save(newModel);
			return ValidationResponce.builder().status(HttpStatus.UNPROCESSABLE_ENTITY.value()).message("Invalid otp")
					.build();
		}
	}

}
